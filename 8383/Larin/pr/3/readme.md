# Практическое задание 3
Ларин Антон  
Гр. 8383
  
## Условие задачи

> Вариант 2 

Написать функцию преобразовывающую вектор чисел в матрицу бинарных представлений.

## Выполнение работы

Для получения вектора-строки бинарного представления восимибитного числа в NumPy служит функция unpackbits  
Для получения бинарного представления произвольных данных произведена их предварительная обработка  
  
Получился следующий код:  
```python
def vec2bin(a):
    a = np.array(a) # Убеждаемся, что работаем с тензором ( преобразовываем в тензор)
    a = a.reshape(a.size,1) # Убеждаемся, что работаем с вектором-столбцом (преобразовываем в вектор-столбец)
    a.dtype = np.uint8 # Приводим в uint8 для преобразования функцией np.unpackbits
    a = a[:, ::-1] # Отзеркаливаем по горизонтали(по вертикальной оси), чтобы младшие адреса располагались справа
    return np.unpackbits(a, axis=1) # Возвращаем бинарное представление


if __name__ == "__main__":
    print(vec2bin(eval(input())))
```
В строке `a.dtype = np.uint8` при замене типа происходит реинтерпретация данных, что позволяет получить бинарное представлений не только целых чисел, но и вещественных

В точке входа происходит считывание строки из входного потока, преобразование в объект функцией `eval`, передача функции `vec2bin`, отвечающей за преобразование. Результат работы выводится в выходной поток  
  
*Использование `eval` считается плохой практикой, но в данном случае это удобно для тестирования*  

## Пример работы программы
1) Пример с целыми числами  
	Входные данные:  
	`[1, 2, 255, 2**63-1, -1]`  
	Выходные данные:
	```
    [[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1]
    [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0]
    [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1]
    [0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
    1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1]
    [1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
    1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1]]
    ```

2) Пример с вещественными числами  
	Входные данные:  
	`[1.0, 2.0, 23.0, 3.0/256]`  
	Выходные данные:
    ```
   [[0 0 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]
    [0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]  
    [0 1 0 0 0 0 0 0 0 0 1 1 0 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]  
    [0 0 1 1 1 1 1 1 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]]
   ```
	[Примеры с википедии для быстрой проверки, что представление верное](https://en.wikipedia.org/wiki/Double-precision_floating-point_format#Double-precision_examples)
