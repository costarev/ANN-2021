## Вариант №5

​	(a **xor** b) **and** (b **xor** c)

## Выполнение работы:

`operation(ex)`  - вычисление нашего выражения

 `naive_simulation` - все операции поэлементно. 

`naive_matrix_vector_dot` -  умножение вектора входных данных на матрицу весов 

 `naive_add` - поэлементное сложение двух векторов. 

 `np_simulation` - работу модели при помощи операций над тензорами из модуля NumPy. 

## Тестирование

Correct result:  [0 0 1 0 0 1 0 0]

Прогон без обучения:
Через модель

[[0.5       ]
 [0.50695795]
 [0.6163634 ]
 [0.53020364]
 [0.5271099 ]
 [0.4958555 ]
 [0.6092009 ]
 [0.55712646]]
Через поэлементные операции:
[[0.5       ]
 [0.50695794]
 [0.6163634 ]
 [0.53020362]
 [0.52710995]
 [0.49585552]
 [0.60920093]
 [0.55712647]]
Через операции над тензорами:
[[0.5       ]
 [0.50695794]
 [0.6163634 ]
 [0.53020362]
 [0.52710995]
 [0.49585552]
 [0.60920093]
 [0.55712647]]

Прогон после обучения:
Через модель
[[0.4616879 ]
 [0.45374367]
 [0.513516  ]
 [0.4035789 ]
 [0.43222028]
 [0.42896056]
 [0.43566006]
 [0.38717982]]
Через поэлементные операции:
[[0.46168788]
 [0.45374366]
 [0.51351599]
 [0.40357889]
 [0.43222026]
 [0.42896055]
 [0.43566003]
 [0.38717982]]
Через операции над тензорами:
[[0.46168788]
 [0.45374366]
 [0.51351599]
 [0.40357889]
 [0.43222025]
 [0.42896055]
 [0.43566004]
 [0.38717982]]

