# Задание

Необходимо реализовать нейронную сеть вычисляющую результат заданной логической операции. Затем реализовать функции, которые будут симулировать работу построенной модели. Функции должны принимать тензор входных данных и список весов. Должно быть реализовано 2 функции:

- Функция, в которой все операции реализованы как поэлементные операции над тензорами
- Функция, в которой все операции реализованы с использованием операций над тензорами из NumPy

Для проверки корректности работы функций необходимо:

1. Инициализировать модель и получить из нее веса 
2. Прогнать датасет через не обученную модель и реализованные 2 функции. Сравнить результат.
3. Обучить модель и получить веса после обучения
4. Прогнать датасет через обученную модель и реализованные 2 функции. Сравнить результат.

# Вариант 3
(a and b) or c


# Выполнение
Входные данные загружаются из файла input.csv - таблица истиности заданного выражения

Реализована нейронная сеть с тремя слоями: входной слой с 8ю нейронами, скрытый слой с 5ю нейронами, выходной слой с одним нейроном. 
На первых двух слоях функция активации - relu, на выходном - sigmoid

Для выполнения поставленной задачи были также реализованы:
функции активации relu и sigmoid
функции скалярного умножения вектора на вектор и матрицы на матрицу
непосредственно функции симуляции работы модели

Функция naive_predict - все операции над тензорами выполняются поэлементно
Именно тут используются реализованные ранее вункции умножения векторов и матриц
Для каждого элемента ветора весов каждого слоя выполняется функция активации текущего слоя
В результате получаем тензор - входные данные для следующего слоя

Функция numpy_predict - операции над тензорами из модуля numpy


Данная задача может быть рассмотрена как задача бинарной классификации, поэтому при обучении модели функция потерь - binary_crossentropy


Рассмотрим полученные результаты работы программы:
До обучениия

Результаты модели:
[[0.5       ]
 [0.46032616]
 [0.48929816]
 [0.42159858]
 [0.49606758]
 [0.50538874]
 [0.5029435 ]
 [0.49191076]]
Результаты операций над тензорами numpy:
[[0.5       ]
 [0.46032617]
 [0.48929818]
 [0.42159859]
 [0.49606758]
 [0.50538871]
 [0.50294354]
 [0.49191074]]
Результаты поэлементных операций над тензорами:
[[0.5       ]
 [0.46032617]
 [0.48929818]
 [0.42159859]
 [0.49606758]
 [0.50538871]
 [0.50294354]
 [0.49191074]]


После обучения

Результаты модели:
[[0.08137029]
 [0.9581424 ]
 [0.06966898]
 [0.994308  ]
 [0.15172067]
 [0.95902216]
 [0.9105109 ]
 [0.99742997]]
Результаты операций над тензорами numpy:
[[0.0813703 ]
 [0.95814239]
 [0.06966903]
 [0.99430806]
 [0.15172061]
 [0.95902215]
 [0.91051084]
 [0.99742991]]
Результаты поэлементных операций над тензорами:
[[0.0813703 ]
 [0.95814239]
 [0.06966903]
 [0.99430806]
 [0.15172061]
 [0.95902215]
 [0.91051084]
 [0.99742991]]


Можно заметить, что реализованные функции дают результаты мало отличающиеся от результатов модели, как до, так и после обучения
Модель и функции симуляции предсказывают результаты достаточно точно
Можно судить о корректной реализации заданных функций
Однако при выборе того, какой метод лучше использовать, стоит учитывать время затраченное на написание кода и исправление ошибок и на надежность выбранного метода