# Практика 4
## Вариант №6

Необходимо реализовать нейронную сеть вычисляющую результат заданной логической операции. Затем реализовать функции, которые будут симулировать работу построенной модели. Функции должны принимать тензор входных данных и список весов. Должно быть реализовано 2 функции:

- Функция, в которой все операции реализованы как поэлементные операции над тензорами
- Функция, в которой все операции реализованы с использованием операций над тензорами из NumPy
Для проверки корректности работы функций необходимо:

- Инициализировать модель и получить из нее веса (Как получить веса слоя, Как получить список слоев модели)
- Прогнать датасет через не обученную модель и реализованные 2 функции. Сравнить результат.
- Обучить модель и получить веса после обучения
- Прогнать датасет через обученную модель и реализованные 2 функции. Сравнить результат.

Примечание: так как множество всех наблюдений ограничен, то обучение проводить можно на всем датасете без контроля.

## Логическое выражение:
    
    (a and not b) or (c xor b)


## Описание решения

Модель сети:
```
model = Sequential()
model.add(Dense(10, activation='relu', input_shape=(3,)))
model.add(Dense(5, activation='relu'))
model.add(Dense(1, activation='sigmoid'))

model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])
conclusion(model, dataset)

model.fit(dataset, correct_result(dataset), epochs=150, batch_size=1)
conclusion(model, dataset)
```
Функция, в которой все операции реализованы как поэлементные операции над тензорами:
```
def function_1(dataset, weights):
    dataset = dataset.copy()
    layers = [relu for i in range(len(weights) - 1)]
    layers.append(sigmoid)                            
    for w in range(len(weights)):
        result = np.zeros((len(dataset), len(weights[w][1])))
        for i in range(len(dataset)):
            for j in range(len(weights[w][1])):
                sum = 0
                for k in range(len(dataset[i])):
                    sum += dataset[i][k] * weights[w][0][k][j]
                result[i][j] = layers[w](sum + weights[w][1][j])
        dataset = result
    return dataset
```
Функция, в которой все операции реализованы с использованием операций над тензорами из NumPy:
```
def function_2(dataset, weights):
    dataset = dataset.copy()
    layers = [relu for i in range(len(weights) - 1)]
    layers.append(sigmoid)
    for i in range(len(weights)):
        dataset = layers[i](np.dot(dataset, weights[i][0]) + weights[i][1])
    return dataset
```
Функция для проверки на правильность результата:
```
def correct_result(dataset):
    return np.array([int(logical_expression(arr[0], arr[1], arr[2])) for arr in dataset])
```

## Пример работы
Прогон датасета через необученную модель:
```
**************************
Правильный результат:
 [0 1 1 0 1 1 1 0]
Результат поэлементых операций:
 [[0.]
 [1.]
 [1.]
 [1.]
 [1.]
 [1.]
 [0.]
 [0.]]
Результат работы с Numpy:
 [[0.]
 [1.]
 [1.]
 [1.]
 [1.]
 [1.]
 [0.]
 [0.]]
Результат работы модели:
 [[0.]
 [1.]
 [1.]
 [1.]
 [1.]
 [1.]
 [0.]
 [0.]]
**************************
```
Прогон датасета через обученную модель:
```
**************************
Правильный результат:
 [0 1 1 0 1 1 1 0]
Результат поэлементых операций:
 [[0.]
 [1.]
 [1.]
 [0.]
 [1.]
 [1.]
 [1.]
 [0.]]
Результат работы с Numpy:
 [[0.]
 [1.]
 [1.]
 [0.]
 [1.]
 [1.]
 [1.]
 [0.]]
Результат работы модели:
 [[0.]
 [1.]
 [1.]
 [0.]
 [1.]
 [1.]
 [1.]
 [0.]]
**************************
```